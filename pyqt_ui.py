
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'form_design.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5 import QtWidgets, QtGui
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import  QFileDialog
import sys
import pyaudio
import time
from PyQt5 import QtCore, QtGui, QtWidgets
from constants import STREAMING_LIMIT, CHUNK_SIZE, STREAMING_CONFIG, SAMPLE_RATE, SILENT_CHUNK
from filter_vocabulary import censFilter
from resumable_mic_stream import audio_stream, ResumableMicrophoneStream
import re
import time
from threading import Lock
import copy
import math
import threading
from google.cloud import speech
import pyaudio
from epydoc.cli import cli
cli()

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(490, 260)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())
        Form.setSizePolicy(sizePolicy)
        Form.setMinimumSize(QtCore.QSize(490, 260))
        Form.setMaximumSize(QtCore.QSize(490, 260))
        font = QtGui.QFont()
        font.setItalic(False)
        font.setUnderline(False)
        font.setStrikeOut(False)
        Form.setFont(font)
        Form.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.pushButton = QtWidgets.QPushButton(Form)
        self.pushButton.setGeometry(QtCore.QRect(160, 90, 121, 41))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(Form)
        self.pushButton_2.setGeometry(QtCore.QRect(320, 140, 121, 101))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(60)
        font.setBold(False)
        font.setWeight(50)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setIconSize(QtCore.QSize(64, 64))
        self.pushButton_2.setObjectName("pushButton_2")
        self.label_5 = QtWidgets.QLabel(Form)
        self.label_5.setGeometry(QtCore.QRect(10, 240, 141, 16))
        self.label_5.setObjectName("label_5")
        self.label = QtWidgets.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(30, 10, 527, 30))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setMinimumSize(QtCore.QSize(400, 30))
        self.label.setObjectName("label")
        self.comboBox = QtWidgets.QComboBox(Form)
        self.comboBox.setGeometry(QtCore.QRect(30, 40, 421, 20))
        self.comboBox.setObjectName("comboBox")
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(30, 75, 109, 30))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_2.sizePolicy().hasHeightForWidth())
        self.label_2.setSizePolicy(sizePolicy)
        self.label_2.setMinimumSize(QtCore.QSize(2, 13))
        self.label_2.setMaximumSize(QtCore.QSize(16777215, 30))
        self.label_2.setSizeIncrement(QtCore.QSize(1, 1))
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.comboBox_2 = QtWidgets.QComboBox(Form)
        self.comboBox_2.setGeometry(QtCore.QRect(54, 105, 60, 20))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.comboBox_2.sizePolicy().hasHeightForWidth())
        self.comboBox_2.setSizePolicy(sizePolicy)
        self.comboBox_2.setMaximumSize(QtCore.QSize(60, 20))
        self.comboBox_2.setBaseSize(QtCore.QSize(60, 20))
        self.comboBox_2.setEditable(False)
        self.comboBox_2.setInsertPolicy(QtWidgets.QComboBox.InsertAtBottom)
        self.comboBox_2.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.comboBox_2.setObjectName("comboBox_2")
        self.groupBox = QtWidgets.QGroupBox(Form)
        self.groupBox.setGeometry(QtCore.QRect(20, 150, 251, 80))
        self.groupBox.setObjectName("groupBox")
        self.label_4 = QtWidgets.QLabel(self.groupBox)
        self.label_4.setGeometry(QtCore.QRect(0, 26, 161, 30))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_4.sizePolicy().hasHeightForWidth())
        self.label_4.setSizePolicy(sizePolicy)
        self.label_4.setMinimumSize(QtCore.QSize(0, 30))
        self.label_4.setScaledContents(False)
        self.label_4.setAlignment(QtCore.Qt.AlignCenter)
        self.label_4.setWordWrap(True)
        self.label_4.setObjectName("label_4")
        self.label_3 = QtWidgets.QLabel(self.groupBox)
        self.label_3.setGeometry(QtCore.QRect(170, 16, 60, 60))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_3.sizePolicy().hasHeightForWidth())
        self.label_3.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily("Segoe Script")
        font.setPointSize(30)
        self.label_3.setFont(font)
        self.label_3.setLineWidth(0)
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.pushButton_2.setEnabled(False)

        self.retranslateUi(Form)
        
        # self.pushButton.clicked.connect(self.label_4.update)
        self.label_4.windowIconTextChanged['QString'].connect(self.label_3.update)
        QtCore.QMetaObject.connectSlotsByName(Form)
            
    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Speech Censor v0.1"))
        self.pushButton.setText(_translate("Form", "Обновить фильтр"))
        self.pushButton_2.setText(_translate("Form", "▶"))
        self.label_5.setText(_translate("Form", "Длительность потока: 0:00 "))
        self.label.setText(_translate("Form", "Источник аудиопотока:"))
        self.label_2.setText(_translate("Form", "Язык распознавания:"))
        self.groupBox.setTitle(_translate("Form", "Состояние"))
        self.label_4.setText(_translate("Form", "Выберите источник"))
        self.label_3.setText(_translate("Form", "❌"))

 
class MainWindow(QtWidgets.QWidget):
    def __init__(self):
        super(MainWindow, self).__init__()
        
        self.ui = Ui_Form()
        self.ui.setupUi(self)
        self.data = "" #tmp
        self.timer = QTimer()
        self.timer.timeout.connect(self.onTimeout)
        self.ui.pushButton.clicked.connect(self.openFileNameDialog)
        self.ui.comboBox.addItem("--Выберите источник ввода--")
        p = pyaudio.PyAudio()
        for i in range(p.get_device_count()):
            if (p.get_device_info_by_index(i).get('maxInputChannels')) > 0:
                self.ui.comboBox.addItem(p.get_device_info_by_index(i).get('name'))
                
        self.ui.comboBox_2.addItem("RU-ru")
        self.start_flag = False
        # self.ui.pushButton_2.clicked.connect(self.startButtonClicked)
        self.ui.pushButton_2.clicked.connect(self.mainActivity)
        self.ui.comboBox.currentIndexChanged['int'].connect(self.audioInputChanged)
        # self.ui.comboBox_2.currentIndexChanged['int'].connect(self.label_4.update)


    
    def get_current_time(self):
        """Return Current Time in MS."""
        return int(round(time.time() * 1000))



    def clear_old_audio(self):
        lock_clear = Lock()
        while True:
            time.sleep(100)
            lock_clear.acquire()
            try:
                audio_stream.input_audio_stream = []
            finally:
                lock_clear.release()  
            

    def load_audio_stream(self):
        lock_load = Lock()
        while True:
            time.sleep(2)
            lock_load.acquire()
            try:  
                tmp = copy.copy(audio_stream.input_audio_stream[audio_stream.last_chunk:audio_stream.last_chunk+20])
                audio_stream.output_audio_stream.put(b"".join(tmp))
                audio_stream.last_chunk = audio_stream.last_chunk + 20
            finally:
                lock_load.release() 
            
            # audio_stream.input_audio_stream = []
            

    def output(self):
        time.sleep(5)
        while True:
            if not audio_stream.output_audio_stream.empty():
                x = audio_stream.output_audio_stream.get()
                audio_stream.out_put.append(x)
                output_stream.write(x)   
            else:
                break



    def listen_print_loop(self,responses, stream,lock):
        """Iterates through server responses and prints them.
        The responses passed is a generator that will block until a response
        is provided by the server.
        Each response may contain multiple results, and each result may contain
        multiple alternatives; for details, see https://goo.gl/tjCPAU.  Here we
        print only the transcription for the top alternative of the top result.
        In this case, responses are provided for interim results as well. If the
        response is an interim one, print a line feed at the end of it, to allow
        the next result to overwrite it, until the response is a final one. For the
        final one, print a newline to preserve the finalized transcription.
        """
        
        for response in responses:
            if self.get_current_time() - stream.start_time > STREAMING_LIMIT:
                stream.start_time = self.get_current_time()
                break

            if not response.results:
                continue

            result = response.results[0]

            if not result.alternatives:
                continue

            transcript = result.alternatives[0].transcript.lower()

            result_seconds = 0
            result_micros = 0

            if result.result_end_time.seconds:
                result_seconds = result.result_end_time.seconds

            if result.result_end_time.microseconds:
                result_micros = result.result_end_time.microseconds

            stream.result_end_time = int((result_seconds * 1000) + (result_micros / 1000))

            corrected_time = (
                stream.result_end_time
                - stream.bridging_offset
                # + (STREAMING_LIMIT * stream.restart_counter)
            )
            tmp = transcript.split(" ")[-1]
            print(tmp)
            if len(tmp)>2 and tmp not in censFilter.stopwords and (tmp in censFilter.vocabulary 
            or censFilter.lemmatizer.parse(tmp)[0].normal_form in censFilter.lem_voc 
            or censFilter.stemmer.stem(tmp) in censFilter.stem_voc): #censor words
                # print("CENSORED")
                start_chunk = (math.floor(corrected_time/100) - 8) % 1000
                for i in range(start_chunk % 1000,(start_chunk+6) % 1000):
                    # print(audio_stream.input_audio_stream[i])
                    
                    lock.acquire()
                    try:
                        audio_stream.input_audio_stream[i] = SILENT_CHUNK
                    finally:
                        lock.release() 
            if result.is_final: 
                stream.is_final_end_time = stream.result_end_time
                # Exit recognition if any of the transcribed phrases could be
                # one of our keywords.
                if re.search(r"\b(выход|quit)\b", transcript, re.I):
                    stream.closed = True
                    break
   
    def openFileNameDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self,"Открыть файл", "","All Files (*.*)", options=options)
        if fileName:
            print(fileName)
            
            f = open(fileName, 'r',encoding="utf-8")		
            with f:
                data1 = f.read()
            self.data = data1.split(" ")
            if len(self.data)> 0 and self.ui.comboBox.currentIndex() != 0:
                censFilter.create(fileName)
                self.ui.label_4.setText("Готово к работе")
                self.ui.label_3.setText("✔️")
                self.ui.pushButton_2.setEnabled(True)
        #     self.label_4.adjustSize()
            else:
                self.ui.label_4.setText("Обновите фильтр")
                self.ui.pushButton_2.setEnabled(False)
                self.ui.label_3.setText("❌")
            print(self.data)
    
    def onTimeout(self):
        cur_time = time.gmtime(time.time()-self.start_time)
        self.ui.label_5.setText('Длительность потока: {0}:{1}:{2}'.format(cur_time.tm_hour,cur_time.tm_min,cur_time.tm_sec))
        self.ui.label_5.adjustSize()   

    def mainActivity(self):
        self.start_flag = not self.start_flag
        if self.start_flag:
            mic_manager = ResumableMicrophoneStream(SAMPLE_RATE, CHUNK_SIZE,self.ui.comboBox.currentIndex())
            output_stream = pyaudio.PyAudio().open(format=pyaudio.paInt16, channels=1, rate=16000, output=True, frames_per_buffer=CHUNK_SIZE)
            lock = Lock()
            client = speech.SpeechClient()
            with mic_manager as stream:
                threading.Thread(name= 'out__put',target=self.output).start()
                threading.Thread(target=self.clear_old_audio,daemon=True).start()
                threading.Thread(target=self.load_audio_stream,daemon=True).start()
                while not stream.closed:

                    audio_generator = stream.generator()
                    requests = (
                        speech.StreamingRecognizeRequest(audio_content=content)
                        for content in audio_generator
                    )
                    responses = client.streaming_recognize(STREAMING_CONFIG, requests)
                    
                    # Now, put the transcription responses to use.
                    self.listen_print_loop(responses, stream,lock)

                    if stream.result_end_time > 0:
                        stream.final_request_end_time = stream.is_final_end_time
                    stream.result_end_time = 0
                    stream.last_audio_input = []
                    stream.last_audio_input = stream.audio_input
                    stream.audio_input = []
                    stream.restart_counter = stream.restart_counter + 1
                    stream.new_stream = True

            self.start_time = time.time()
            self.ui.pushButton_2.setText("■")
            self.setWindowTitle("🔴Speech Censor v0.1")
            self.ui.comboBox.setEnabled(False)
            self.ui.comboBox_2.setEnabled(False)
            self.ui.pushButton.setEnabled(False)
            self.ui.label_4.setText("В эфире")
            self.ui.label_3.setText("🔴")
            self.timer.start(1000)
            # self.ui.label_5.adjustSize()
            # self.ui.label_3.setText("✅")
        else:
            self.ui.pushButton_2.setText("▶")
            self.ui.comboBox.setEnabled(True)
            self.ui.comboBox_2.setEnabled(True)
            self.ui.pushButton.setEnabled(True)
            self.setWindowTitle("Speech Censor v0.1")
            self.ui.label_4.setText("Готово к работе")
            self.ui.label_3.setText("✔️")
            self.timer.stop()
            # self.ui.label_3.setText("❎")
        print(self.start_flag)
        
    def audioInputChanged(self):
        print(self.ui.comboBox.currentIndex())
        if self.ui.comboBox.currentIndex() != 0 and len(self.data)> 0:
            self.ui.label_4.setText("Готово к работе")
            self.ui.label_3.setText("✔️")
            self.ui.pushButton_2.setEnabled(True)
        elif self.ui.comboBox.currentIndex() != 0:
            self.ui.label_4.setText("Обновите фильтр")
            self.ui.pushButton_2.setEnabled(False)
            self.ui.label_3.setText("❌")
        #     self.label_4.adjustSize()
        else:
            self.ui.label_4.setText("Выберите источник")
            self.ui.pushButton_2.setEnabled(False)
            self.ui.label_3.setText("❌")
        #     self.label_4.adjustSize()
            # Если не использовать, то часть текста исчезнет.





